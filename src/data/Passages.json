[{
        "bID": 52,
        "bsubmitter": "1",
        "btitle": "1",
        "bcategory": "技术博文",
        "bcontent": "<p>1</p>",
        "btraffic": 13,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 51,
        "bsubmitter": "123",
        "btitle": "123",
        "bcategory": "技术博文",
        "bcontent": "<p>123</p>",
        "btraffic": 7,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "123",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 50,
        "bsubmitter": "fffff",
        "btitle": "Mvc model验证总结",
        "bcategory": "技术博文",
        "bcontent": "<h2>Model&nbsp;验证总结 </h2><p><a href=\"https://www.cnblogs.com/starksoft/p/5616889.html\" target=\"_blank\">https://www.cnblogs.com/starksoft/p/5616889.html</a></p><p><br></p><p><br></p><p><br></p><p>Model&nbsp;验证总结&nbsp;1</p><p>一．Model&nbsp;验证标记&nbsp;1</p><p>1、启用客户端验证： 1</p><p>2、在&nbsp;Model&nbsp;中加入验证标记&nbsp;2</p><p>3&nbsp;、&nbsp;Model&nbsp;类中可以添加的验证标记：&nbsp;3</p><p>3.1、必填字段 3</p><p>3.2&nbsp;、&nbsp;字段长度 3</p><p>3.3&nbsp;、&nbsp;正则验证 3</p><p>3.4、范围 4</p><p>3.5、服务端参与的验证 4</p><p>3.6、比较 4</p><p>3.7、自定义错",
        "btraffic": 298,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "Model验证总结 https://www.cnblogs.com/starksoft/p/5616889.htmlModel验证总结1一．Model验证标记11、启用客户端验证： 12、在Model中加入验证标记23、Model类中可以添加的验证标记：33.1、必填字段 33.2、字段长度 33.3、正则验证 33.4、范围 43.5、服务端参与的验证 43.6、比较 43.7、自定义错误消息 ",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 48,
        "bsubmitter": "学习",
        "btitle": "《WebAPI Get请求参数传入输入带有[]不识别问题》",
        "bcategory": "技术博文",
        "bcontent": "<p>在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式</p><p>1.https://localhost:44390/api/values?status=1&amp;status=2</p><p>2.https://localhost:44390/api/values?status[]=1&amp;status[]=2</p><p>3.https://localhost:44390/api/values?status[0]=1&amp;status[1]=2</p><p><br></p><p>&lt;img src=\"<span style=\"background-color: rgb(255, 255, 255);\">http://123.206.33.109:7090/images%5C0506120113image.png</span>\" /&gt;</p><p><br></p><p>直到客户端同鞋找到我，才发现第二种在.net core webapi 默认竟然不支持</p><p>于是google了好久加上询问大牛，才找到",
        "btraffic": 115,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式1.https://localhost:44390/api/values?status=1status=22.https://localhost:44390/api/values?status[]=1status[]=23.https://localhost:44390/api/values?s",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 46,
        "bsubmitter": "学习",
        "btitle": ".Net Core 迁移之坑一 《WebAPI Get请求参数传入输入带有[]不识别问题》",
        "bcategory": "技术博文",
        "bcontent": "<p>在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式</p><p>1.https://localhost:44390/api/values?status=1&amp;status=2</p><p>2.https://localhost:44390/api/values?status[]=1&amp;status[]=2</p><p>3.https://localhost:44390/api/values?status[0]=1&amp;status[1]=2</p><p><img src=\"https://images2018.cnblogs.com/blog/384514/201807/384514-20180715165114365-1220720659.png\"></p><p>直到客户端同鞋找到我，才发现第二种在.net core webapi 默认竟然不支持</p><p>于是google了好久加上询问大牛，才找到一个解决方案，就是通过&nbsp;Conventions 解决</p><p><img src=\"https:/",
        "btraffic": 90,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "在Framwork 体系下 WebAPI项目 会有很多默认特性，例如：Get查询竟然支持三种数组查询方式1.https://localhost:44390/api/values?status=1status=22.https://localhost:44390/api/values?status[]=1status[]=23.https://localhost:44390/api/values?s",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 42,
        "bsubmitter": "对对对",
        "btitle": "代码：JS继承 + C# 单例模式",
        "bcategory": "技术博文",
        "bcontent": "<h2>&nbsp;单例模型</h2><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"> &nbsp; public class Singleton\n&nbsp; &nbsp; {\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 定义一个静态变量来保存类的实例\n&nbsp; &nbsp; &nbsp; &nbsp; private static Singleton uniqueInstance;\n&nbsp; &nbsp; &nbsp; &nbsp; // 定义一个标识确保线程同步\n&nbsp; &nbsp; &nbsp; &nbsp; private static readonly object locker = new object();\n&nbsp; &nbsp; &nbsp; &nbsp; // 定义私有构造函数，使外界不能创建该类实例\n&nbsp; &nbsp; &nbsp; &nbsp; private Singleton()\n&nbsp; &nbsp; &nbsp; &nbsp; {\n&nbsp; &",
        "btraffic": 220,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "单例模型  public class Singleton\n  {\n\n    // 定义一个静态变量来保存类的实例\n    private static Singleton uniqueInstance;\n    // 定义一个标识确保线程同步\n    private static readonly object locker = new object();\n    // 定义私有构造函数，使外界不",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 41,
        "bsubmitter": "IIS",
        "btitle": "IIS的工作原理？",
        "bcategory": "技术博文",
        "bcontent": "<p>1、当客户端发送HTTP Request时，服务端的HTTP.sys（可以理解为IIS的一个监听组件） 拦截到这个请求；</p><p>2、HTTP.sys 联系 WAS 向配置存储中心请求配置信息。</p><p>3、然后将请求传入IIS的应用程序池。</p><p>4、检查请求的后缀，启动aspnet_isapi.dll这个dll，这个dll是.net framework里面的，也就是说到这一步，请求进入了.net framework的管辖范围。</p><p>5、这个时候如果是WebForm，开始执行复杂的页面生命周期（HttpRuntime→ProcessRequest→HttpContext→HttpHandler）；如果是MVC，则启动mvc的路由机制，根据路由规则为URL来指定HttpHandler。</p><p>6、httpHandler处理请求后，请求结束，给出Response，客户端处理响应，整个过程结束。</p>",
        "btraffic": 120,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1、当客户端发送HTTP Request时，服务端的HTTP.sys（可以理解为IIS的一个监听组件） 拦截到这个请求；2、HTTP.sys 联系 WAS 向配置存储中心请求配置信息。3、然后将请求传入IIS的应用程序池。4、检查请求的后缀，启动aspnet_isapi.dll这个dll，这个dll是.net framework里面的，也就是说到这一步，请求进入了.net framework的管辖",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 40,
        "bsubmitter": "laozhang",
        "btitle": "谈谈你觉得做的不错系统，大概介绍下用到了哪些技术？",
        "bcategory": "技术博文",
        "bcontent": "<p> </p><p>就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。</p><p><br></p><p>1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给上层提供实现，而是提供接口，具体的实现以依赖注入的方式在运行的时候动态注入进去。MEF就是实现依赖注入的一种组件。它的使用使得UI 层不直接依赖于BLL层，而是依赖于中间的一个IBLL层，在程序运行的时候，通过MEF动态将BLL里面的实现注入到UI层里面去，这样做的好处是减少 了层与层之间的耦合。服务端的异常里面、权限验证、日志记录等通用功能使用了AOP拦截的机制统一管理，项目中使用的是Postsharp这个组件，很好 地将通用需求功能从不相关的类当中分离出来，提高了代码的可维护性。</p><p><br></p><p>2、BS的客户端采用",
        "btraffic": 203,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": " 就拿我之前做过的一个项目为例来简单说明一下吧。项目分为客户端和服务端，客户端分 为BS客户端和CS客户端，BS客户端采用MVC 5.0的框架，CS客户端是Winform项目，服务端使用WebApi统一提供服务接口，考虑以后可能还要扩展手机端，所以服务接口的参数和返回值使用 通用的Json格式来传递数据。1、服务端采用的面向接口编程，我们在软件架构的过程中，层和层之间通过接口依赖， 下层不是直接给",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 39,
        "bsubmitter": "xxx",
        "btitle": "MVC路由理解？",
        "bcategory": "技术博文",
        "bcontent": "<p>1、首先我们要理解MVC中路由的作用：url Routing的作用是将浏览器的URL请求映射到特定的MVC控制器动作。</p><p><br></p><p>2、当我们访问http://localhost:8080/Home/Index 这个地址的时候，请求首先被UrlRoutingModule截获，截获请求后，从Routes中得到与当前请求URL相符合的RouteData对象， 将RouteData对象和当前URL封装成一个RequestContext对象，然后从Requestcontext封装的RouteData中得到 Controller名字，根据Controller的名字，通过反射创建控制器对象，这个时候控制器才真正被激活，最后去执行控制器里面对应的 action。</p>",
        "btraffic": 42,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1、首先我们要理解MVC中路由的作用：url Routing的作用是将浏览器的URL请求映射到特定的MVC控制器动作。2、当我们访问http://localhost:8080/Home/Index 这个地址的时候，请求首先被UrlRoutingModule截获，截获请求后，从Routes中得到与当前请求URL相符合的RouteData对象， 将RouteData对象和当前URL封装成一个Reque",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 37,
        "bsubmitter": "ddd",
        "btitle": "对于 Web 性能优化，您有哪些了解和经验吗？",
        "bcategory": "技术博文",
        "bcontent": "<p><br></p><h3><strong>1、前端优化</strong></h3><p><br></p><p>（1）减少&nbsp;HTTP 请求的次数。我们知道每次发送http请求，建立连接和等待相应会花去相当一部分时间，所以在发送http请求的时候，尽量减少请求的次数，一次请求能取出的数据就不要分多次发送。</p><p>（2）启用浏览器缓存，当确定请求的数据不会发生变化时，能够直接读浏览器缓存的就不要向服务端发送请求。比如我们ajax里面有一个参数能够设置请求的时候是否启用缓存，这种情况下就需要我们在发送请求的时候做好相应的缓存处理。</p><p>（3）css文件放 在&lt;head&gt;里面，js文件尽量放在页面的底部。因为请求js文件是很花费时间，如果放在&lt;head&gt;里面，就会导致页面的 DOM树呈现需要等待js文件加载完成。这也就是为什么很多网站的源码里面看到引用的文件放在最后的原因。</p><p>（4）使用压缩的css和js文件。这个不用多说，网络流量小。</p><p>（5）如果条件允许，尽量使用CDN的方式引用文件，这样就能减少网络流量。比如我们常用的",
        "btraffic": 32,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1、前端优化（1）减少HTTP 请求的次数。我们知道每次发送http请求，建立连接和等待相应会花去相当一部分时间，所以在发送http请求的时候，尽量减少请求的次数，一次请求能取出的数据就不要分多次发送。（2）启用浏览器缓存，当确定请求的数据不会发生变化时，能够直接读浏览器缓存的就不要向服务端发送请求。比如我们ajax里面有一个参数能够设置请求的时候是否启用缓存，这种情况下就需要我们在发送请求的时候",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 36,
        "bsubmitter": "laozhang",
        "btitle": "总结const、readonly、static三者的区别",
        "bcategory": "技术博文",
        "bcontent": "<p><span style=\"background-color: rgb(255, 255, 0);\">const：</span>静态常量，也称编译时常量(compile-time constants)，属于类型级，通过类名直接访问，被所有对象共享！</p><p>a、叫编译时常量的原因是它编译时会将其替换为所对应的值；</p><p>b、静态常量在速度上会稍稍快一些，但是灵活性却比动态常量差一些；</p><p>c、静态常量，隐式是静态的，即被static隐式修饰过，不能再用static重复修饰，</p><p>d、在声明时初始化；</p><p>e、静态常量只能被声明为简单的数据类型(内建的int和浮点型)、枚举或字符串。</p><p>f、应用场合例如:Math.PI的定义（要声明一些从不改变且处处唯一的常量，就应该使用静态常量）</p><p>&nbsp;</p><p><span style=\"background-color: rgb(255, 255, 0);\">readonly：</span>动态常量，也称运行时常量(runtime constants)，属于对象级，通过对象访问。<",
        "btraffic": 31,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "const：静态常量，也称编译时常量(compile-time constants)，属于类型级，通过类名直接访问，被所有对象共享！a、叫编译时常量的原因是它编译时会将其替换为所对应的值；b、静态常量在速度上会稍稍快一些，但是灵活性却比动态常量差一些；c、静态常量，隐式是静态的，即被static隐式修饰过，不能再用static重复修饰，d、在声明时初始化；e、静态常量只能被声明为简单的数据类型(内",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 35,
        "bsubmitter": "老张",
        "btitle": "Session原理 知多少",
        "bcategory": "技术博文",
        "bcontent": "<h2><span style=\"color: rgb(51, 51, 51);\">一、session是怎么存储，提取的？</span></h2><p><br></p><p>1、在服务器端有一个session池，用来存储每个用户提交session中的数据，Session对于每一个客户端（或者说浏览器实例）是“人手一份”，用户首次与Web服务器建立连接的时候，服务器会给用户分发一个SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在HTTP头中提交给Web服务器，这样Web服务器就能区分当前请求页面的是哪一个客户端,而这个SessionID是一cookie的方式保存的在客户端的内存中的，如果想要得到Session池中的数据，服务器就会根据客户端提交的唯一SessionID标识给出相应的数据返回。</p><p><br></p><p>2、输入正确的账号密码，点击登录，页面就会输出&nbsp;“admin --- 点击登录”</p><p><br></p><h2>二、Session池中每个客户端的数据是怎么存",
        "btraffic": 8,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "一、session是怎么存储，提取的？1、在服务器端有一个session池，用来存储每个用户提交session中的数据，Session对于每一个客户端（或者说浏览器实例）是“人手一份”，用户首次与Web服务器建立连接的时候，服务器会给用户分发一个SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在HTTP头中提",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 34,
        "bsubmitter": "admin",
        "btitle": "asp.net 中的app_offline.htm的使用",
        "bcategory": "技术博文",
        "bcontent": "<p>前段时间，系统升级，由于系统更新发布时间较长，所以必须停掉站点进行更新。导致很多用户都来反馈系统无法访问，还认为站点被黑掉了。</p><p>所以经过那件事我们也在思考，如何做到不停机，进行热部署。单机环境下（双机或是分布式系统不用考虑这个问题），app_offline.htm是个不错的选择，</p><p>当asp.net看到应用程序中app_offline.htm文件时，它会关闭应用程序的app-domain,然后将请求发给app_offline的内容。</p><p>所以，在维护，升级的时候，就不必停止你的WEB应用程序，而是一个友好的方式提示给用户，本网站正在更新的提示，这样体验会更友好。</p><p>&nbsp;</p><p>1. 创建一个app_offline.htm的HTM页面文件，</p><p><br></p><pre>&lt;html&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=\"Content-Type\"\r\ncontent=\"text/html; charset=gb2312\"&gt;\r\n&lt;title&gt;站点更新中&lt;",
        "btraffic": 533,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "前段时间，系统升级，由于系统更新发布时间较长，所以必须停掉站点进行更新。导致很多用户都来反馈系统无法访问，还认为站点被黑掉了。所以经过那件事我们也在思考，如何做到不停机，进行热部署。单机环境下（双机或是分布式系统不用考虑这个问题），app_offline.htm是个不错的选择，当asp.net看到应用程序中app_offline.htm文件时，它会关闭应用程序的app-domain,然后将请求发给",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 33,
        "bsubmitter": "admin",
        "btitle": ".net 网站实现 HTTPS 访问，并自动跳转",
        "bcategory": "技术博文",
        "bcontent": "<h1>准备</h1><p>1.购买一台<a href=\"https://www.qcloud.com/product/cvm?fromSource=gwzcw.84824.84824.84824\" target=\"_blank\">腾讯云CVM</a>\r\n2.拥有一个已经在腾讯云备案成功的域名。</p><h1>演示环境</h1><p>系统：windows2008R2\r\n软件：IIS7.0，IIS的microsoft URL重写模块2.0</p><h1>操作步骤：</h1><h2>1、给已备案的域名申请SSL证书并下载到服务器</h2><figure><div><img src=\"https://blog-10039692.file.myqcloud.com/1488272147475_1642_1488272148299.png\"></div></figure><p>这里我们使用IIS环境，所以选择IIS文件夹中的证书文件</p><figure><div><img src=\"https://blog-10039692.file.myqcloud.com/1488272223004_95",
        "btraffic": 198,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "准备1.购买一台腾讯云CVM\r\n2.拥有一个已经在腾讯云备案成功的域名。演示环境系统：windows2008R2\r\n软件：IIS7.0，IIS的microsoft URL重写模块2.0操作步骤：1、给已备案的域名申请SSL证书并下载到服务器这里我们使用IIS环境，所以选择IIS文件夹中的证书文件2、打开IIS信息服务管理器部署SSL证书并绑定域名、开放并绑定端口首先导入证书 （注意这个是在IIS里",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 32,
        "bsubmitter": "admin",
        "btitle": "EF 第三篇 生产环境下的数据迁移 ",
        "bcategory": "技术博文",
        "bcontent": "<p>步骤</p><p>1、创建实体</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"java hljs\" codemark=\"1\">using System.ComponentModel.DataAnnotations.Schema;\r\n \r\nnamespace Migration\r\n{\r\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span>\r\n    </span>{\r\n        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]\r\n        <span class=\"hljs-keyword\">public</span> Guid Id { get; set; }\r\n      <span cl",
        "btraffic": 94,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "步骤1、创建实体using System.ComponentModel.DataAnnotations.Schema;\r\n \r\nnamespace Migration\r\n{\r\n    public class User\r\n    {\r\n        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]\r\n        public",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 31,
        "bsubmitter": "admin",
        "btitle": "netcore实现静态项目",
        "bcategory": "技术博文",
        "bcontent": "<p>修改&nbsp;<span style=\"color: inherit;\">launchSettings.json ——》》</span><span style=\"color: inherit;\">&nbsp;\"launchUrl\":&nbsp;\"swagger\",</span></p><p>&nbsp; app.UseDefaultFiles();</p><p>&nbsp;&nbsp;&nbsp;app.UseStaticFiles();</p><p>&nbsp;</p><p>https://www.cnblogs.com/hantianwei/p/5641705.html</p><p><br></p><p>&nbsp; app.UseDefaultFiles();</p><p>&nbsp;&nbsp;&nbsp;app.UseStaticFiles();</p><p>&nbsp;<span style=\"color: inherit;\">https://www.cnblogs.com/hantianwei/p/5641705.html</span></p><p>&nbsp; ",
        "btraffic": 291,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "修改launchSettings.json ——》》\"launchUrl\":\"swagger\", app.UseDefaultFiles();app.UseStaticFiles();https://www.cnblogs.com/hantianwei/p/5641705.html app.UseDefaultFiles();app.UseStaticFiles();https://www.cnb",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 30,
        "bsubmitter": "admin",
        "btitle": "c# order by 字符型的数字时候，排序错误问题",
        "bcategory": "技术博文",
        "bcontent": "<p>比如：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"java hljs\" codemark=\"1\">List&lt;digitalModel&gt; digitalStrs = <span class=\"hljs-keyword\">new</span> List&lt;digitalModel&gt;() {\r\n     <span class=\"hljs-keyword\">new</span> digitalModel {\r\n        digitalStr=<span class=\"hljs-string\">\"124844130139102\"</span>,<span class=\"hljs-comment\">//小</span>\r\n    },\r\n    <span class=\"hljs-keyword\">new</span> digitalModel {\r\n        digitalStr=<span class=\"hljs-string\">\"1000152864394053\"</sp",
        "btraffic": 73,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "比如：ListdigitalModel digitalStrs = new ListdigitalModel() {\r\n     new digitalModel {\r\n        digitalStr=\"124844130139102\",//小\r\n    },\r\n    new digitalModel {\r\n        digitalStr=\"1000152864394053\",//大",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 26,
        "bsubmitter": "admin",
        "btitle": ".net core2.0 api + Swagger + Resposity Service +  ",
        "bcategory": "技术博文",
        "bcontent": "<h1>1 .Net Core API 2.0</h1><p><img src=\"http://blog.azlinli.com/upload/image/20180817/20180817102427_5196.png\" alt=\"\"><br></p><p><img src=\"http://blog.azlinli.com/upload/image/20180817/20180817102603_5665.png\" alt=\"\"><br></p><p><img src=\"http://blog.azlinli.com/upload/image/20180817/20180817103015_6915.png\" alt=\"\"><br></p><p><br></p>\r\n<hr><hr>\r\n<br><h1>2 Swagger</h1><p><br></p><p><img src=\"http://blog.azlinli.com/upload/image/20180817/20180817104510_1759.png\" alt=\"\"><br></p><p><br></p><pre styl",
        "btraffic": 80,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1 .Net Core API 2.0\r\n\r\n2 Swagger  // This method gets called by the runtime. Use this method to add services to the container.\r\n        public void ConfigureServices(IServiceCollection services)\r\n    ",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 25,
        "bsubmitter": "admin",
        "btitle": "MVC Rator语法，通配分页，简洁高效",
        "bcategory": "技术博文",
        "bcontent": "<pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">\r\n@{\r\n    int pageindex = (int)ViewData[<span class=\"hljs-string\">\"pageNumberIndex\"</span>];\r\n    int pagecount = (int)ViewData[<span class=\"hljs-string\">\"PageCount\"</span>];\r\n    string otherPara = (string)ViewData[<span class=\"hljs-string\">\"PageOtherPara\"</span>];\r\n    int showPageCount = <span class=\"hljs-number\">9</span>;\r\n    string pageParaName = <span class=\"hljs-string\">\"page\"</span>;\r\n    string page",
        "btraffic": 80,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "\r\n@{\r\n    int pageindex = (int)ViewData[\"pageNumberIndex\"];\r\n    int pagecount = (int)ViewData[\"PageCount\"];\r\n    string otherPara = (string)ViewData[\"PageOtherPara\"];\r\n    int showPageCount = 9;\r\n   ",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 24,
        "bsubmitter": "admin",
        "btitle": "原生 js ajax 请求 写法 简单",
        "bcategory": "技术博文",
        "bcontent": "<p>var&nbsp;Ajax={\r\n</p><p>&nbsp;&nbsp;get:&nbsp;function(url,&nbsp;fn)&nbsp;{\r\n</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;XMLHttpRequest对象用于在后台与服务器交换数据&nbsp;&nbsp;&nbsp;\r\n</p><p>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;xhr&nbsp;=&nbsp;new&nbsp;XMLHttpRequest();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</p><p>&nbsp;&nbsp;&nbsp;&nbsp;xhr.open('GET',&nbsp;url,&nbsp;true);\r\n</p><p>&nbsp;&nbsp;&nbsp;&nbsp;xhr.onreadystatechange&nbsp;=&nbsp;function()&nbsp;{\r\n</p><p>&nbsp;&nbsp;&n",
        "btraffic": 29,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "varAjax={\r\nget:function(url,fn){\r\n//XMLHttpRequest对象用于在后台与服务器交换数据\r\nvarxhr=newXMLHttpRequest();\r\nxhr.open('GET',url,true);\r\nxhr.onreadystatechange=function(){\r\n//readyState==4说明请求已完成\r\nif(xhr.readyState",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 23,
        "bsubmitter": "admin",
        "btitle": "关于.net 项目中的仓储模式 Respository + Service模式",
        "bcategory": "技术博文",
        "bcontent": "<pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">在Asp.net MVC controller的底层，常常有提到repository和service layer, 好像都是逻辑相关的层，那么它们到底是什么区别呢？\r\n\r\n简单的说：\r\n\r\nrepository就是一个管理数据持久层的，它负责数据的CRUD(Create, Read, Update, Delete)\r\n\r\nservice layer是业务逻辑层，它常常需要访问repository层，但是它不关心数据是如何获取和存储的。</code></pre><p><img src=\"http://blog.azlinli.com/upload/image/20180809/20180809151419_6761.png\" alt=\"\"><br></p><p><br></p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript h",
        "btraffic": 33,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "在Asp.net MVC controller的底层，常常有提到repository和service layer, 好像都是逻辑相关的层，那么它们到底是什么区别呢？\r\n\r\n简单的说：\r\n\r\nrepository就是一个管理数据持久层的，它负责数据的CRUD(Create, Read, Update, Delete)\r\n\r\nservice layer是业务逻辑层，它常常需要访问repository层",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 22,
        "bsubmitter": "admin",
        "btitle": "泛型list 去重 备份知识",
        "bcategory": "技术博文",
        "bcontent": "<h1><a href=\"https://www.cnblogs.com/hao-1234-1234/p/8855218.html\">【C#】list 去重（转载）</a><br>原作者：<a href=\"https://www.cnblogs.com/hao-1234-1234/p/8855218.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255); font-size: 13px;\">https://www.cnblogs.com/hao-1234-1234/p/8855218.html</a></h1><h1>&nbsp;</h1><p>Enumerable.Distinct 方法&nbsp;是常用的LINQ扩展方法，属于System.Linq的Enumerable方法，可用于去除数组、集合中的重复元素，还可以自定义去重的规则。</p><p>有两个重载方法：</p><p><a href=\"javascript:void(0);\"><img src=\"https://common.cnblogs.com",
        "btraffic": 19,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "【C#】list 去重（转载）原作者：https://www.cnblogs.com/hao-1234-1234/p/8855218.htmlEnumerable.Distinct 方法是常用的LINQ扩展方法，属于System.Linq的Enumerable方法，可用于去除数组、集合中的重复元素，还可以自定义去重的规则。有两个重载方法：        //\r\n        // 摘要: \r\n ",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 21,
        "bsubmitter": "admin",
        "btitle": "c#  用@符号，字符串中有引号，怎么正则，贼溜！",
        "bcategory": "技术博文",
        "bcontent": "<pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Regex regex = <span class=\"hljs-keyword\">new</span> Regex(@<span class=\"hljs-string\">\"https://www\\.amazon\\.com/gp/video/detail/\\w+\"</span>);\r\n            Regex regex2= <span class=\"hljs-keyword\">new</span> Regex(<span class=\"hljs-string\">\"href=\\\"(https://www\\\\.amazon\\\\.com/gp/video/detail/\\\\w+)/.*?\\\"&gt;.*?src=\\\"http\"</span>);\r\n\r\n        ",
        "btraffic": 40,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "Regex regex = new Regex(@\"https://www\\.amazon\\.com/gp/video/detail/\\w+\");\r\n            Regex regex2= new Regex(\"href=\\\"(https://www\\\\.amazon\\\\.com/gp/video/detail/\\\\w+)/.*?\\\".*?src=\\\"http\");\r\n\r\n      ",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 20,
        "bsubmitter": "admin",
        "btitle": "async和await 异步多线程记录",
        "bcategory": "技术博文",
        "bcontent": "<p><img src=\"http://blog.azlinli.com/upload/image/20180731/20180731165751_9464.png\" alt=\"\"><br></p><p><img src=\"http://blog.azlinli.com/upload/image/20180731/20180731165804_1027.png\" alt=\"\"><br></p><p><br></p>",
        "btraffic": 28,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 19,
        "bsubmitter": "admin",
        "btitle": "如何扒取网站信息 贼溜",
        "bcategory": "技术博文",
        "bcontent": "<pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> Main(string[] args)\r\n        {\r\n            <span class=\"hljs-comment\">//从指定的地址加载html文档 Jumony.Core</span>\r\n            IHtmlDocument source = <span class=\"hljs-keyword\">new</span> JumonyParser().LoadDocument(<span class=\"hljs-string\">\"http://www.cnblogs.com/cate/csharp\"</span>);\r\n            <span class=\"hljs-keyword\">var</span",
        "btraffic": 27,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "  static void Main(string[] args)\r\n        {\r\n            //从指定的地址加载html文档 Jumony.Core\r\n            IHtmlDocument source = new JumonyParser().LoadDocument(\"http://www.cnblogs.com/cate/csharp\");\r\n     ",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 18,
        "bsubmitter": "admin",
        "btitle": "强大的json转换，vs  一键快速json转实体类",
        "bcategory": "技术博文",
        "bcontent": "<p><span style=\"color: inherit;\">强大的json转换，vs&nbsp;&nbsp;一键快速json转实体类</span></p><p><img src=\"http://blog.azlinli.com/upload/image/20180727/20180727151044_7745.png\" alt=\"\"><br></p><p><br></p>",
        "btraffic": 17,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "强大的json转换，vs一键快速json转实体类",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 17,
        "bsubmitter": "admin",
        "btitle": "expects the parameter '@GameDate', which was not supplied.\"\tstring  对于  我设了null，但是往数据库里写的时候提醒不能为null怎么办",
        "bcategory": "技术博文",
        "bcontent": "<pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\">    public <span class=\"hljs-keyword\">static</span> object GetSingle(string SQLString, params SqlParameter[] cmdParms)\r\n        {\r\n            using (SqlConnection connection = <span class=\"hljs-keyword\">new</span> SqlConnection(connectionString))\r\n            {\r\n                using (SqlCommand cmd = <span class=\"hljs-keyword\">new</span> SqlCommand())\r\n                {\r\n                    <span class=\"hlj",
        "btraffic": 14,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "    public static object GetSingle(string SQLString, params SqlParameter[] cmdParms)\r\n        {\r\n            using (SqlConnection connection = new SqlConnection(connectionString))\r\n            {\r\n    ",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 16,
        "bsubmitter": "admin",
        "btitle": "泛型初探  第一次",
        "bcategory": "技术博文",
        "bcontent": "<p>什么是泛型</p><p><br></p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp;我们在编写程序时，经常遇到两个模块的功能非常相似，只是一个是处理int数据，另一个是处理string数据，或者其他自定义的数据类型，但我们没有办法，只能分别写多个方法处理每个数据类型，因为方法的参数类型不同。有没有一种办法，在方法中传入通用的数据类型，这样不就可以合并代码了吗？泛型的出现就是专门解决这个问题的。读完本篇文章，你会对泛型有更深的了解。</p><p><br></p><p>为什么要使用泛型</p><p>为了了解这个问题，我们先看下面的代码，代码省略了一些内容，但功能是实现一个栈，这个栈只能处理int数据类型：</p><p><br></p><p>public class Stack</p><p><br></p><p>&nbsp; &nbsp; {</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; private int[] m_item;</p><p><br></p><p>&nbsp; &nbsp; &nbsp;",
        "btraffic": 21,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "什么是泛型   我们在编写程序时，经常遇到两个模块的功能非常相似，只是一个是处理int数据，另一个是处理string数据，或者其他自定义的数据类型，但我们没有办法，只能分别写多个方法处理每个数据类型，因为方法的参数类型不同。有没有一种办法，在方法中传入通用的数据类型，这样不就可以合并代码了吗？泛型的出现就是专门解决这个问题的。读完本篇文章，你会对泛型有更深的了解。为什么要使用泛型为了了解这个问题，",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 15,
        "bsubmitter": "admin",
        "btitle": "异步学习 异步委托 ",
        "bcategory": "技术博文",
        "bcontent": "<h1>异步委托</h1><h1><p><img src=\"http://blog.azlinli.com/upload/image/20180719/20180719151628_3995.png\" alt=\"\"></p></h1><blockquote><p><font color=\"#ff0000\">同步方法会卡住界面，异步方法不卡界面，原因是异步启动了多个线程执行计算任务，主线程没有被占用</font></p></blockquote><p>666666666666666666</p><p><img src=\"http://blog.azlinli.com/upload/image/20180720/20180720154802_6652.png\" alt=\"\"><br></p><p><img src=\"http://blog.azlinli.com/upload/image/20180720/20180720172537_0089.png\" alt=\"\"><br></p><p><img src=\"http://blog.azlinli.com/upload/image/201",
        "btraffic": 32,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "异步委托同步方法会卡住界面，异步方法不卡界面，原因是异步启动了多个线程执行计算任务，主线程没有被占用666666666666666666*",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 14,
        "bsubmitter": "admin",
        "btitle": "Lambda 表达式,源于委托",
        "bcategory": "技术博文",
        "bcontent": "<p><img src=\"http://blog.azlinli.com/upload/image/20180719/20180719125553_5249.png\" alt=\"\"><br></p><p>************************************************************************************************************</p><p><img src=\"http://blog.azlinli.com/upload/image/20180719/20180719125818_2914.png\" alt=\"\" class=\"clicked\"><br></p><blockquote><p><font color=\"#ff0000\">lambda表达式 把delegate换成了=&gt;&nbsp; 箭头的左边是参数列表，右边是方法体</font></p></blockquote><p><img src=\"http://blog.azlinli.com/upload/image/20180719/",
        "btraffic": 19,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "************************************************************************************************************lambda表达式 把delegate换成了= 箭头的左边是参数列表，右边是方法体WithReturnWithPara func=(x,y) = { return x+y; };Wit",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 13,
        "bsubmitter": "admin",
        "btitle": "委托学习 解耦 ++ 事件",
        "bcategory": "技术博文",
        "bcontent": "<h1><span style=\"color: inherit;\">1、委托</span></h1><p><img src=\"http://blog.azlinli.com/upload/image/20180719/20180719113530_4152.png\" alt=\"\"><br></p><p>***********************************</p><blockquote><p><font color=\"#ff0000\">委托的调用，</font></p></blockquote><blockquote><p><font color=\"#ff0000\">method.Invoke(3,4);</font></p><p><font color=\"#ff0000\">method(5,6);</font></p><p><font color=\"#ff0000\">method.BeginInvoke(6,7,null,null);//异步调用</font></p></blockquote><p><br></p><p>&&amp;&amp;&amp;&amp;&am",
        "btraffic": 23,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1、委托***********************************委托的调用，method.Invoke(3,4);method(5,6);method.BeginInvoke(6,7,null,null);//异步调用上边的是定义了一个委托，然后呢，接下来是实例化一个委托:GreetingHandler handlerChinese = new GreetingHandler(Gre",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 12,
        "bsubmitter": "admin",
        "btitle": "23中设计模式",
        "bcategory": "技术博文",
        "bcontent": "<h1>1、单例模式</h1><p><img src=\"http://blog.azlinli.com/upload/image/20180718/20180718105749_8370.png\" alt=\"\" class=\"\"></p><br><p><font color=\"#ff0000\">************************************************************************************************************************************</font></p><p><img src=\"http://blog.azlinli.com/upload/image/20180718/20180718105907_9620.png\" alt=\"\" class=\"\"><br></p><p><font color=\"#ff0000\">****************************************************************************",
        "btraffic": 22,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1、单例模式**************************************************************************************************************************************************************************************************",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 11,
        "bsubmitter": "admin",
        "btitle": "C#  反射初探",
        "bcategory": "技术博文",
        "bcontent": "<p>1、什么是反射&nbsp; &nbsp; &nbsp; &nbsp; Reflection，中文翻译为反射。&nbsp; &nbsp; &nbsp; &nbsp; 这是.Net中获取运行时类型信息的方式，.Net的应用程序由几个部分：‘程序集(Assembly)’、‘模块(Module)’、‘类型(class)’组成，而反射提供一种编程的方式，让程序员可以在程序运行期获得这几个组成部分的相关信息，例如：&nbsp; &nbsp; &nbsp; &nbsp; Assembly类可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并创建该类型的实例。Type类可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性等等，通过Type类可以得到这些要素的信息，并且调用之。MethodInfo包含方法的信息，通过这个类可以得到方法的名称、参数、返回值等，并且可以调用之。诸如此类，还有FieldInfo、EventInfo等等，这些类都包含在System.Reflection命名空间下。2、命名空间与装配件的关系&nbsp; &nbsp; &nbs",
        "btraffic": 27,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "1、什么是反射    Reflection，中文翻译为反射。    这是.Net中获取运行时类型信息的方式，.Net的应用程序由几个部分：‘程序集(Assembly)’、‘模块(Module)’、‘类型(class)’组成，而反射提供一种编程的方式，让程序员可以在程序运行期获得这几个组成部分的相关信息，例如：    Assembly类可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 10,
        "bsubmitter": "admin",
        "btitle": "纯Javascript 手写 全选/全不选 反选 单选 等",
        "bcategory": "技术博文",
        "bcontent": "<pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"html hljs xml\" codemark=\"1\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\r\n<span class=\"hljs-selector-tag\">td</span> {\r\n    <span class=\"hljs-attribute\">border-right</span>: <span class=\"hljs-number\">1px</span> dashed;\r\n    <span class=\"hljs-attribute\">border-bottom</span>: <span class=\"hljs-number\">1px</span> dashed;\r\n}\r\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>",
        "btraffic": 17,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "style\r\ntd {\r\n    border-right: 1px dashed;\r\n    border-bottom: 1px dashed;\r\n}\r\n/style\r\n\r\ndiv\r\n\ttable\r\n\tthead\r\n\t\ttdinput type=\"checkbox\" name=\"allCheck\" onclick=\"allCheck();\" /全选   input type=\"checkbox",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 9,
        "bsubmitter": "admin",
        "btitle": "如何将本地代码上传到Github",
        "bcategory": "技术博文",
        "bcontent": "<p>重大的GIT：</p><p><a href=\"https://github.com/anjoy8/AZLinli.com.git\" target=\"_blank\">https://github.com/anjoy8/AZLinli.com.</a></p><p><a href=\"https://github.com/anjoy8/AZLinli.ORM.git\" target=\"_blank\">https://github.com/anjoy8/AZLinli.ORM</a></p><p><a href=\"https://github.com/anjoy8/AZLinli.Blog\" target=\"_blank\">https://github.com/anjoy8/AZLinli.Blog</a></p><p><br></p><p>1、下载Git，注册账号，等待略</p><p>2、Github创建项目<br><img src=\"http://blog.azlinli.com/upload/image/20180711/20180711165751_0536.png\" alt=\"",
        "btraffic": 45,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "重大的GIT：https://github.com/anjoy8/AZLinli.com.https://github.com/anjoy8/AZLinli.ORMhttps://github.com/anjoy8/AZLinli.Blog1、下载Git，注册账号，等待略2、Github创建项目3、Code所在根目录执行git initgit add .git commit -m \"first c",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 8,
        "bsubmitter": "admin",
        "btitle": "厉害了，JS中 0.1+0.2 != 0.3！！！",
        "bcategory": "技术博文",
        "bcontent": "<blockquote><p>console.log(0.1 + 0.2)  // 结果是0.30000000000000004，而不是 0.3</p></blockquote><h2>这里0.1 + 0.2 != 0.3&nbsp;这个就是我们要解决的问题了。</h2><p>要弄清这个问题的原因，首先我们需要了解下在计算机中数字是如何存储和运算的。在计算机中，数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的。在JS中数字采用的IEEE 754的双精度标准进行存储，我们可以无需知道他的存储形式，只需要简单的理解成就是存储一个数值所使用的二进制位数比较多而已，这样得到的数会更加精确。</p><p>这里为了简单直观，我们使用定点数来说明问题。在定点数中，如果我们以8位二进制来存储数字。</p><blockquote><p>对于整数来说，十进制的35会被存储为：&nbsp;00100011&nbsp;其代表&nbsp;2^5 + 2^1 + 2^0。对于纯小数来说，十进制的0.375会被存储为：&nbsp;0.011&nbsp;其代表&nbsp;1/2^2 + 1/2^3&nbsp",
        "btraffic": 23,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "console.log(0.1 + 0.2)  // 结果是0.30000000000000004，而不是 0.3这里0.1 + 0.2 != 0.3这个就是我们要解决的问题了。要弄清这个问题的原因，首先我们需要了解下在计算机中数字是如何存储和运算的。在计算机中，数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的。在JS中数字采用的IEEE 754的双精度标准进行存储，我们可以无需知道他的",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 7,
        "bsubmitter": "admin",
        "btitle": "Js，为什么if 表达式中有逗号表达式",
        "bcategory": "技术博文",
        "bcontent": "<p>比如：</p><pre style=\"max-width:100%;overflow-x:auto;\"><code class=\"javascript hljs\" codemark=\"1\"><span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">4</span>, j = <span class=\"hljs-number\">10</span>;\r\n\r\n<span class=\"hljs-keyword\">if</span>((i &gt; <span class=\"hljs-number\">5</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>),i = <span class=\"hljs-number\">5</span>,j &gt; <span class=\"hljs-number\">8</span>)\r\n{\r\n    alert(<span class=\"hljs-st",
        "btraffic": 16,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "比如：var i = 4, j = 10;\r\n\r\nif((i  5 ? true : false),i = 5,j  8)\r\n{\r\n    alert(\"这里会被执行，并且i变成了5\") \r\n}解答：其实上面的代码可以这样写：var i = 4, j = 10;\r\n(i  5 ? ture : false);\r\ni=5;\r\nif(j  8)\r\n{\r\n    alert(\"这里会被执行，并且i变成了",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 6,
        "bsubmitter": "admin",
        "btitle": "CodeFirst完美解决数据迁移-记录中-更新版",
        "bcategory": "技术博文",
        "bcontent": "<p><br>------------------2018-06-25 06:44-------------------------</p><p>迁移至指定版本（包括后退）</p><p>　　迄今为止，我们总是升级至最新迁移，然而某些时候我们需要升级/降级至指定版本，例如我们想迁移数据库至运行&nbsp;AddBlogUrl&nbsp;迁移之后的状态，此时我们就可以使用&nbsp;–TargetMigration&nbsp;来降级到这个版本</p><p>　　在&nbsp;Package Manager Console&nbsp;中运行命令&nbsp;Update-Database –TargetMigration: AddBlogUrl&nbsp;</p><p>&nbsp;<img src=\"http://blog.azlinli.com/upload/image/20180625/20180625185757_6161.png\" alt=\"\" style=\"color: inherit;\" class=\"\"></p><p style=\"width:100%;\"><br></p><p s",
        "btraffic": 48,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "------------------2018-06-25 06:44-------------------------迁移至指定版本（包括后退）　　迄今为止，我们总是升级至最新迁移，然而某些时候我们需要升级/降级至指定版本，例如我们想迁移数据库至运行AddBlogUrl迁移之后的状态，此时我们就可以使用–TargetMigration来降级到这个版本　　在Package Manager Conso",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 3,
        "bsubmitter": "admin",
        "btitle": "Redis在windows下安装过程",
        "bcategory": "技术博文",
        "bcontent": "                        <p>去官网找了很久，发现原来在官网上可以下载的windows版本的，现在官网以及没有下载地址，只能在github上下载，官网只提供linux版本的下载</p><p>官网下载地址：<a href=\"http://redis.io/download\">http://redis.io/download</a></p><p>github下载地址：<a href=\"https://github.com/MSOpenTech/redis/tags\">https://github.com/MSOpenTech/redis/tags</a></p><p>在运行中输入cmd，然后把目录指向解压的Redis目录。</p><p>redis-server redis.windows.conf，出现下图显示表示启动成功了。</p><p>1、由于上面虽然启动了redis，但是只要一关闭cmd窗口，redis就会消失。所以要把redis设置成windows下的服务。</p><p>也就是设置到这里，首先发现是没用这个Redis服务的。</p><p>2、设置服务命令</",
        "btraffic": 23,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "                        去官网找了很久，发现原来在官网上可以下载的windows版本的，现在官网以及没有下载地址，只能在github上下载，官网只提供linux版本的下载官网下载地址：http://redis.io/downloadgithub下载地址：https://github.com/MSOpenTech/redis/tags在运行中输入cmd，然后把目录指向解压的R",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 2,
        "bsubmitter": "admin",
        "btitle": "The 'targetFramework' attribute in the <compilation> element of the Web.config file is used only to target version 4.0 and later of the .N",
        "bcategory": "技术博文",
        "bcontent": "                            <p>The&nbsp;'targetFramework'&nbsp;attribute&nbsp;in&nbsp;the&nbsp;&lt;compilation&gt;&nbsp;element&nbsp;of&nbsp;the&nbsp;Web.config&nbsp;file&nbsp;is&nbsp;used&nbsp;only&nbsp;to&nbsp;target&nbsp;version&nbsp;4.0&nbsp;and&nbsp;later&nbsp;of&nbsp;the&nbsp;.NET&nbsp;Framework&nbsp;(for&nbsp;example,&nbsp;'&lt;compilation&nbsp;targetFramework=\"4.0\"&gt;').&nbsp;The&nbsp;'targetFramework'&nbsp;attribute&nbsp;currently&nbsp;references&nbsp;a&nbsp;version&nbsp;that&nbsp;is&n",
        "btraffic": 68,
        "bcommentNum": 0,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "                            The'targetFramework'attributeinthecompilationelementoftheWeb.configfileisusedonlytotargetversion4.0andlaterofthe.NETFramework(forexample,'compilationtargetFramework=\"4.0\"')",
        "IsDeleted": false,
        "href": "/"
    },
    {
        "bID": 1,
        "bsubmitter": "admin",
        "btitle": "IIS new add website ，some wrong:The requested page cannot be accessed because the related configuration data for the page is invalid.",
        "bcategory": "技术博文",
        "bcontent": "                            <p>Question:</p><h1><a href=\"https://www.cnblogs.com/yipeng-yu/p/6210380.html\">The requested page cannot be accessed because the related configuration data for the page is invalid.</a></h1><p>HTTP Error 500.19 - Internal Server Error The requested page cannot be accessed because the related configuration data for the page is invalid.</p><p>Detailed Error Information:</p><p>Module IIS Web Core</p><p>Notification Unknown</p><p>Handler Not yet determined</p><p>Error Code",
        "btraffic": 127,
        "bcommentNum": 1,
        "bUpdateTime": "2019-01-01T00:00:00",
        "bCreateTime": "2019-01-01T00:00:00",
        "bRemark": "                            Question:The requested page cannot be accessed because the related configuration data for the page is invalid.HTTP Error 500.19 - Internal Server Error The requested page c",
        "IsDeleted": false,
        "href": "/"
    }
]